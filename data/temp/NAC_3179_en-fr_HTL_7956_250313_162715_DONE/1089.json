{
    "source": "en_US",
    "target": "fr_FR",
    "text": "One method for ameliorating this problem is to perform the client's movement locally and just assume, temporarily, that the server will accept and acknowledge the client commands directly. This method is labeled as client-side prediction.\nClient-side prediction of movements requires us to let go of the \"dumb\" or minimal client principle. That's not to say that the client is fully in control of its simulation, as in a peer-to-peer game with no central server. There still is an authoritative server running the simulation just as noted above. Having an authoritative server means that even if the client simulates different results than the server, the server's results will eventually correct the client's incorrect simulation. Because of the latency in the connection, the correction might not occur until a full round trip's worth of time has passed. The downside is that this can cause a very perceptible shift in the player's position due to the fixing up of the prediction error that occurred in the past.\nTo implement client-side prediction of movement, the following general procedure is used. As before, client inputs are sampled and a user command is generated. Also as before, this user command is sent off to the server. However, each user command (and the exact time it was generated) is stored on the client. The prediction algorithm uses these stored commands.\nFor prediction, the last acknowledged movement from the server is used as a starting point. The acknowledgement indicates which user command was last acted upon by the server and also tells us the exact position (and other state data) of the player after that movement command was simulated on the server. The last acknowledged command will be somewhere in the past if there is any lag in the connection. For instance, if the client is running at 50 frames per second (fps) and has 100 milliseconds of latency (roundtrip), then the client will have stored up five user commands ahead of the last one acknowledged by the server. These five user commands are simulated on the client as a part of client-side prediction. Assuming full prediction1, the client will want to start with the latest data from the server, and then run the five user commands through \"similar logic\" to what the server uses for simulation of client movement. Running these commands should produce an accurate final state on the client (final player position is most important) that can be used to determine from what position to render the scene during the current frame.\nIn Half-Life, minimizing discrepancies between client and server in the prediction logic is accomplished by sharing the identical movement code for players in both the server-side game code and the client-side game code. These are the routines in the pm_shared/ (which stands for \"player movement shared\") folder of the HL SDK. The input to the shared routines is encapsulated by the user command and a \"from\" player state. The output is the new player state after issuing the user command. The general algorithm on the client is as follows:",
    "trans": "Une méthode pour améliorer ce problème consiste à effectuer localement les mouvements du client et à supposer temporairement que le serveur acceptera et reconnaîtra directement les commandes du client. Cette méthode est appelée prédiction côté client.\nLa prédiction côté client des mouvements nécessite de renoncer au principe du \"client minimal\" ou \"idiot\". Cela ne signifie pas que le client contrôle entièrement sa simulation, comme dans un jeu pair-à-pair sans serveur central. Il y a toujours un serveur autoritaire exécutant la simulation comme indiqué ci-dessus. Avoir un serveur autoritaire signifie que même si le client simule des résultats différents de ceux du serveur, les résultats du serveur corrigeront finalement la simulation incorrecte du client. En raison de la latence de la connexion, la correction peut ne pas se produire avant qu'un temps de trajet complet ne se soit écoulé. L'inconvénient est que cela peut provoquer un changement très perceptible dans la position du joueur en raison de la correction de l'erreur de prédiction qui s'est produite dans le passé.\nPour implémenter la prédiction côté client des mouvements, la procédure générale suivante est utilisée. Comme précédemment, les entrées du client sont échantillonnées et une commande utilisateur est générée. De même, cette commande utilisateur est envoyée au serveur. Cependant, chaque commande utilisateur (et l'heure exacte à laquelle elle a été générée) est stockée sur le client. L'algorithme de prédiction utilise ces commandes stockées.\nPour la prédiction, le dernier mouvement reconnu par le serveur est utilisé comme point de départ. La reconnaissance indique quelle commande utilisateur a été la dernière à être exécutée par le serveur et nous indique également la position exacte (et d'autres données d'état) du joueur après que cette commande de mouvement a été simulée sur le serveur. La dernière commande reconnue sera quelque part dans le passé s'il y a un décalage dans la connexion. Par exemple, si le client fonctionne à 50 images par seconde (fps) et a une latence de 100 millisecondes (aller-retour), alors le client aura stocké cinq commandes utilisateur à l'avance par rapport à la dernière reconnue par le serveur. Ces cinq commandes utilisateur sont simulées sur le client dans le cadre de la prédiction côté client. En supposant une prédiction complète, le client voudra commencer par les dernières données du serveur, puis exécuter les cinq commandes utilisateur via une \"logique similaire\" à celle que le serveur utilise pour la simulation des mouvements du client. L'exécution de ces commandes devrait produire un état final précis sur le client (la position finale du joueur est la plus importante) qui peut être utilisé pour déterminer à partir de quelle position rendre la scène pendant l'image actuelle.\nDans Half-Life, minimiser les divergences entre le client et le serveur dans la logique de prédiction est réalisé en partageant le même code de mouvement pour les joueurs dans le code du jeu côté serveur et le code du jeu côté client. Ces routines se trouvent dans le dossier pm_shared/ (qui signifie \"partagé pour les mouvements des joueurs\") du SDK HL. L'entrée des routines partagées est encapsulée par la commande utilisateur et un état \"de\" joueur. La sortie est le nouvel état du joueur après l'émission de la commande utilisateur. L'algorithme général sur le client est le suivant :"
}