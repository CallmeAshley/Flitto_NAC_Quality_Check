{
    "source": "en_US",
    "target": "ko_KR",
    "text": "One method for ameliorating this problem is to perform the client's movement locally and just assume, temporarily, that the server will accept and acknowledge the client commands directly. This method is labeled as client-side prediction.\nClient-side prediction of movements requires us to let go of the \"dumb\" or minimal client principle. That's not to say that the client is fully in control of its simulation, as in a peer-to-peer game with no central server. There still is an authoritative server running the simulation just as noted above. Having an authoritative server means that even if the client simulates different results than the server, the server's results will eventually correct the client's incorrect simulation. Because of the latency in the connection, the correction might not occur until a full round trip's worth of time has passed. The downside is that this can cause a very perceptible shift in the player's position due to the fixing up of the prediction error that occurred in the past.\nTo implement client-side prediction of movement, the following general procedure is used. As before, client inputs are sampled and a user command is generated. Also as before, this user command is sent off to the server. However, each user command (and the exact time it was generated) is stored on the client. The prediction algorithm uses these stored commands.\nFor prediction, the last acknowledged movement from the server is used as a starting point. The acknowledgement indicates which user command was last acted upon by the server and also tells us the exact position (and other state data) of the player after that movement command was simulated on the server. The last acknowledged command will be somewhere in the past if there is any lag in the connection. For instance, if the client is running at 50 frames per second (fps) and has 100 milliseconds of latency (roundtrip), then the client will have stored up five user commands ahead of the last one acknowledged by the server. These five user commands are simulated on the client as a part of client-side prediction. Assuming full prediction1, the client will want to start with the latest data from the server, and then run the five user commands through \"similar logic\" to what the server uses for simulation of client movement. Running these commands should produce an accurate final state on the client (final player position is most important) that can be used to determine from what position to render the scene during the current frame.\nIn Half-Life, minimizing discrepancies between client and server in the prediction logic is accomplished by sharing the identical movement code for players in both the server-side game code and the client-side game code. These are the routines in the pm_shared/ (which stands for \"player movement shared\") folder of the HL SDK. The input to the shared routines is encapsulated by the user command and a \"from\" player state. The output is the new player state after issuing the user command. The general algorithm on the client is as follows:",
    "trans": "이 문제를 개선하는 한 가지 방법은 클라이언트의 움직임을 로컬에서 처리하고, 임시로, 서버가 클라이언트의 명령을 즉시 수락하고 승인할 것이라고 가정하는 것이다. 이 방법을 클라이언트 측 예측이라고 한다.\n움직임에 대한 클라이언트 측 예측은 \"단순함\" 또는 최소한의 클라이언트 원칙을 포기해야 한다. 이는 클라이언트가 완전히 독립적으로 시뮬레이션을 제어한다는 의미는 아니며, 중앙 서버가 없는 피어투피어 게임처럼 동작하는 것도 아니다. 위의 언급한 것처럼 여전히 권한을 가진 서버가 있고 이 서버가 시뮬레이션을 실행한다. 권한을 가진 서버가 존재한다는 것은 설령 클라이언트가 서버와 다른 결과를 시뮬레이션하더라도, 결국 서버의 결과가 클라이언트의 잘못된 시뮬레이션을 수정하게 된다는 의미이다. 연결 지연으로 인해, 이 수정은 서버와의 왕복 시간이 지나기 전까지 적용되지 않을 수도 있다. 단점은 과거의 예측 오류를 수정하는 과정에서 플레이어의 위치에 눈에 띄는 변화를 발생시킬 수 있다는 점이다.\n움직임에 대한 클라이언트 측 예측을 적용하려면, 다음과 같은 일반적인 절차가 활용된다. 이전과 마찬가지로, 클라이언트 입력이 샘플링되며 사용자 명령이 생성된다. 또한 이전처럼, 이 사용자 명령은 서버로 전송된다. 그러나, 각 사용자 명령(및 해당 명령이 생성된 정확한 시간)이 클라이언트에 저장된다. 예측 알고리즘은 이 저장된 명령을 사용한다.\n예측을 위해, 서버에서 마지막으로 승인한 움직임이 시작점으로 사용된다. 이 승인은 서버가 마지막으로 처리한 사용자 명령을 나타내며 또한 해당 명령이 서버에서 시뮬레이션된 후의 플레이어의 정확한 위치(및 기타 상태 데이터)를 제공한다. 만약 연결에 지연이 존재한다면 마지막 승인된 명령은 과거의 명령일 가능성이 높다. 예를 들어, 클라이언트가 초당 50프레임(fps)으로 실행되며 (왕복) 지연 시간이 100밀리초라고 가정하면, 클라이언트는 서버가 마지막으로 승인한 명령보다 앞선 다섯 개의 사용자 명령을 저장하게 된다. 이 5개의 사용자 명령은 클라이언트 측 예측의 일부로 시뮬레이션된다. 완전한 예측을 가정하면, 클라이언트는 서버에서 받은 최신 데이터를 시작점으로 설정한 후, 서버가 클라이언트 이동을 시뮬레이션할 때 사용하는 것과 \"유사한 로직\"을 통해 다섯 개의 사용자 명령을 실행하게 된다. 이 명령들을 실행하면 클라이언트에서 정확한 최종 상태(특히 최종 플레이어 위치가 가장 중요함)를 계산할 수 있으며 이를 기반으로 현재 프레임에서 장면을 어떤 위치에서 렌더링할지 결정할 수 있다.\n하프라이프에서는, 예측 로직에서 클라이언트와 서버 간의 불일치를 최소화하기 위해 서버 측 게임 코드와 클라이언트 측 게임 코드에서 동일한 이동 코드를 공유하는 방식을 사용한다. 이 코드들은 하프라이프 소프트웨어 개발 키트 내 pm_shared/ (\"플레이어 움직임 공유\"라는 의미) 폴더에 위치한 루틴들이다. 이 공유 루틴의 입력은 사용자 명령과 \"이전\" 플레이어 상태로 캡슐화된다. 출력은 사용자 명령이 적용된 후의 새로운 플레이어 상태이다. 클라이언트에서의 일반적인 알고리즘은 다음과 같다:"
}